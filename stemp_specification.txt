Stemp Templating language specification
=======================================

Stemp is a very, very simple templating language. It's *S*imple *Temp*lating.
haha, get it?

Anyways, it's pretty easy to use.

Template files
==============
Template files should be named <filename>.stemp.  This should include the file
extension, so if you are templating `nginx.conf`, your template should be named
`nginx.cong.stemp`.

If you don't want to do this, whatever, It's only PART OF THE GODDAMN SPEC!!!!
But seriously, if you don't this won't blow up. This is literally just a
convention I made up while sitting in a massage chair because I wanted to make
up a convention.

What's inside the file should be *exactly* what you want the output to look
like, with one exception. Well, usually there should be a bunch of exceptions,
but you get what I mean.  Wherever you want Stemp to render a value, you need
to add a token.  What's a token? Simple: it's a word surrounded by "$(" and ")"
It doesnt even have to be a word. It can literally be anything.  Well not
*anything*, you can't put like, a banana in there.  Unless it's a banana emoji.
that *might* work, but frankly I haven't tested it.

What are tokens for? Easy - playing arcade games! Wait, no wrong kind of token.
Actually, they're used to mark places in the template where Stemp will insert a
value.  The whole token, "$(" and ")" included will be swapped out for whatever
the matching value in the values file is.

What's the values file, you ask? Good question! It's a file in JSON format
containing the dictionary that Stemp will use to turn tokens into actual text
in the output. So if your values file contains `{'cows': 'say moo'}`, then the
token `$(cows)` will be turned into `say moo` in the output file.

Example
=======
Lets say you have a template file named `friends.txt.stemp`. It has the
following content:
```
My name is $(my_name), And I have friends. My best friend is $(best_friend),
and my worst enemy is $(total_douchecanoe).
```

You also create a values file named `monday.json` with the following content:
```
{
  "my_name": "Ash Ketchum",
  "best_friend": "Pikachu",
  "total_douchecanoe": "Gary Oldman"
}
```

You want to create a file named `friends.txt`, so you'd run this
command:
```
stemp monday.json --input-template friends.txt.stemp
```

The output would be:
```
My name is Ash Ketchum, And I have friends. My best friend is Pikachu,
and my worst enemy is Gary Oldman.
```

Yay! you made the right output! But this didn't go to a file.  You could either
use UNIX output redirection to save the file:
```
stemp monday.json --input-template friends.txt.stemp > friends.txt
```

Or, you could use the --output-file flag to have stemp create the file for you
```
stemp monday.json --input-template friends.txt.stemp --output-file friends.txt
```

If you used a different values file (tuesday.txt):
```
{
  "my_name": "Skeletor",
  "best_friend": "Prince Adam",
  "total_douchecanoe": "He-Man"
}
```

The output would be:
```
My name is Skeletor, And I have friends. My best friend is Prince Adam,
and my worst enemy is He-Man.
```

Optional Arguments
==================

--input-template <template_path>
You don't have to pass in the `--input-template` parameter every time if you
don't want to. If that parameter is omitted, Stemp will read the template from
stdin.  It'll write output every time it hits a newline, and exit when it hits
an EOD marker.

--output-file <output_path>
As you my have noticed from the presense or absence of the `--output-file`
parameter in the example, it is also optional.  If omitted, the rendered file
will be printed to stdout.

--recursion-strategy <strategy_name>
Dictates the way Stemp handles recursive tokens. Current options are:
```
iterative: check the looked-up value for contained tokens before inserting into
  the output document.  The entire value is buffered for this, until the
  resulting output string contains no more tokens, then it is output, line by
  line, until no more newlines remain in the output buffer.  If a token loop is
  detected, the value inserted will be "TOKEN LOOP(<token>):<line_number>",
  where <token> is the token that Stemp is attempting to render when it detects
  the loop, and <line_number> is the line number of the input template that
  the first token that led to the loop was found.

none: Just don't do it. Tokens will be rendered to their mapped values
  verbatim, and will not be analyzed for recursion at all.  This is helpful if
  you want to do any post-processing, or multi-pass renders.

--token-marker <marker_string>

--token-delimiter <delimiter_string>

--strict-mode



Recursive Tokens
================
Know what would be really cool? If tokens could contain tokens. Well guess
what Stemp can do! If a token is found and replaced, The replacement value of
that token will immediately be checked for further contained tokens, and those
tokens will be rendered out as well. More tokens then? fine! It'll continue
forever (or at least to some point where it would make sense to be all like
"screw you guys i'm going home"). If a circularly nested token is found, It'll
instead be replaced with "LOOPED TOKEN:(<token>)". I'll also do my best to make
this give a clear picture of where in the token's recursion tree the loop was
discovered, so you can fix your values easily.  TODO: There are probably other
ways to handle bad recursive tokens, and I'll try and make those other ways
options, with the `--recursion-strategy` parameter.

Array and Hash Tokens
============
Ok, fine you want more? Alright, last one!  Stemp support what I call 'array
and hash tokens'. What're those? It's when the values file maps a json object
or array to a token instead of a string.  That's useful for grouping tokens
in the values file, or if there is a set of data to be rendered out.

Arry tokens can be used in 2 ways: indexed and non-indexed. Indexed array
tokens look like this:
```
$(page[3])
```

The '[' and ']' characters are special, but *only* if they are balanced in the
token.
